# Observer v0.5 Implementation Plan

## Executive Summary

Observer v0.5 is a complete architectural rewrite implementing three core patterns:

1. **MVC (Model-View-Controller)** - Clean separation of data (SQLite), business logic (filter pipelines), and UI (Bubble Tea)
2. **GDC (Grand Dispatch Central)** - Unified async work pool with priority queue for all background operations
3. **Reranking as Filters** - Filter pipeline pattern where cheap filters run first, expensive filters (reranking) only see pre-filtered candidates

---

## Phase Overview

| Phase | Name | Key Deliverables |
|-------|------|------------------|
| 1 | Foundation | Work pool, model layer, basic store |
| 2 | Controller Core | Filter interface, pipeline, basic filters |
| 3 | View Layer | Bubble Tea integration, stream view |
| 4 | Intake Pipeline | Embedding, dedup, storage pipeline |
| 5 | Advanced Filters | Embedding filter, relevance/rerank filter |
| 6 | Integration & Polish | Full MVC wiring, testing, optimization |

---

## Phase 1: Foundation

**Goal:** Establish the core infrastructure that all other components depend on.

### 1.1 Project Structure

```
observer/
├── cmd/observer/main.go           # Entry point
├── internal/
│   ├── model/                     # MODEL layer
│   │   ├── item.go                # Item type definition
│   │   ├── store.go               # SQLite persistence
│   │   └── store_test.go
│   ├── work/                      # GDC - Grand Dispatch Central
│   │   ├── types.go               # Work item types, priorities
│   │   ├── pool.go                # Work pool implementation
│   │   ├── priority_queue.go      # Heap-based priority queue
│   │   ├── ring.go                # Ring buffer for history
│   │   └── work_test.go
│   ├── logging/                   # Structured logging
│   │   └── logger.go
│   └── config/                    # Configuration
│       └── config.go
├── go.mod
├── go.sum
└── CLAUDE.md
```

### 1.2 Work Pool (GDC)

**Files to create:**
- `internal/work/types.go`
- `internal/work/pool.go`
- `internal/work/priority_queue.go`
- `internal/work/ring.go`

**Key Interface:**

```go
// Priority levels for work items (higher = more urgent)
const (
    PriorityBackground = -10  // Batch work: embeds, dedup, cleanup
    PriorityLow        = 0    // Deferred: non-urgent background tasks
    PriorityNormal     = 10   // Standard: scheduled fetches (default)
    PriorityHigh       = 50   // Important: breaking news sources
    PriorityUrgent     = 100  // User-initiated: manual refresh, analysis
    PriorityCritical   = 200  // System-critical: shutdown tasks
)

// Type categorizes work items
type Type string
const (
    TypeFetch   Type = "fetch"
    TypeDedup   Type = "dedup"
    TypeEmbed   Type = "embed"
    TypeRerank  Type = "rerank"
    TypeFilter  Type = "filter"
    TypeAnalyze Type = "analyze"
    TypeIntake  Type = "intake"
)

// Item represents a unit of async work
type Item struct {
    ID          string
    Type        Type
    Status      Status
    Description string
    Priority    int
    CreatedAt   time.Time
    StartedAt   time.Time
    FinishedAt  time.Time
    Progress    float64
    Result      string
    Error       error
    Data        any
}

// Pool manages async work processing
type Pool interface {
    Start(ctx context.Context)
    Stop()
    Submit(item *Item) string
    SubmitFunc(typ Type, desc string, fn func() (string, error)) string
    SubmitWithPriority(typ Type, desc string, priority int, fn func() (string, error)) string
    Subscribe() <-chan Event
    Snapshot() Snapshot
    Stats() Stats
}
```

**Implementation notes:**
- Use `container/heap` for O(log n) priority queue operations
- Worker count defaults to `runtime.NumCPU()`
- Signal-based work dispatch (non-blocking channel)
- Ring buffer for completed work history (last 100 items)
- Event subscription for UI updates

### 1.3 Model Layer

**Files to create:**
- `internal/model/item.go`
- `internal/model/store.go`

**Key Types:**

```go
// SourceType identifies the origin of a feed item
type SourceType string
const (
    SourceRSS        SourceType = "rss"
    SourceHN         SourceType = "hn"
    SourceReddit     SourceType = "reddit"
)

// Item represents a single piece of content
type Item struct {
    ID         string
    Source     SourceType
    SourceName string
    Title      string
    Summary    string
    URL        string
    Author     string
    Published  time.Time
    Fetched    time.Time
    Read       bool
    Saved      bool
    Embedding  []float32  // For semantic operations
}

// TimeBand for UI grouping
type TimeBand int
const (
    TimeBandJustNow TimeBand = iota  // < 15 min
    TimeBandPastHour                  // < 1 hour
    TimeBandToday                     // < 24 hours
    TimeBandYesterday                 // < 48 hours
    TimeBandOlder                     // >= 48 hours
)

// Store interface for persistence
type Store interface {
    SaveItems(items []Item) (int, error)
    GetItems(limit int, includeRead bool) ([]Item, error)
    GetItemsSince(since time.Time) ([]Item, error)
    MarkRead(id string) error
    MarkSaved(id string, saved bool) error
    SaveEmbedding(id string, embedding []float32) error
    SaveEmbeddings(embeddings map[string][]float32) error
    GetItemsWithEmbeddings(limit int, since time.Time) ([]Item, error)
    GetItemsWithoutEmbedding(limit int) ([]Item, error)
    ItemCount() (int, error)
    Close() error
}
```

**SQLite Schema:**

```sql
CREATE TABLE items (
    id TEXT PRIMARY KEY,
    source_type TEXT NOT NULL,
    source_name TEXT NOT NULL,
    title TEXT NOT NULL,
    summary TEXT,
    url TEXT,
    author TEXT,
    published_at DATETIME NOT NULL,
    fetched_at DATETIME NOT NULL,
    read INTEGER DEFAULT 0,
    saved INTEGER DEFAULT 0,
    hidden INTEGER DEFAULT 0,
    embedding BLOB
);

CREATE INDEX idx_items_published ON items(published_at DESC);
CREATE INDEX idx_items_source ON items(source_name);
CREATE INDEX idx_items_no_embedding ON items(embedding) WHERE embedding IS NULL;
```

### 1.4 Testing Strategy (Phase 1)

- Unit tests for priority queue (heap operations, ordering)
- Unit tests for ring buffer (push, overflow, retrieval order)
- Unit tests for work pool (submit, complete, cancel, stats)
- Unit tests for store (CRUD operations, transactions)
- Integration test: work pool with multiple concurrent workers

### 1.5 Phase 1 Success Criteria

- [ ] Work pool passes all tests
- [ ] Priority queue correctly orders items
- [ ] Store CRUD operations work
- [ ] Embedding serialization round-trips correctly

---

## Phase 2: Controller Core

**Goal:** Implement the filter pipeline that is the heart of the Controller layer.

### 2.1 Filter Interface

**File:** `internal/controller/filter.go`

```go
// Filter transforms a set of items
type Filter interface {
    // Name returns the filter name for logging and debugging
    Name() string

    // Run executes the filter on the given items
    Run(ctx context.Context, items []model.Item, pool *work.Pool) ([]model.Item, error)
}

// SyncFilter is a helper for filters that don't need async work
type SyncFilter struct {
    name string
    fn   func(ctx context.Context, items []model.Item) ([]model.Item, error)
}
```

### 2.2 Pipeline

**File:** `internal/controller/pipeline.go`

```go
// Pipeline runs a sequence of filters on items
type Pipeline struct {
    filters []Filter
}

func NewPipeline() *Pipeline
func (p *Pipeline) Add(f Filter) *Pipeline  // Returns self for chaining
func (p *Pipeline) Run(ctx context.Context, items []model.Item, pool *work.Pool) ([]model.Item, error)
```

**Implementation notes:**
- Check context cancellation between each filter stage
- Wrap filter errors with filter name for debugging

### 2.3 Built-in Filters

**Directory:** `internal/controller/filters/`

| Filter | File | Purpose |
|--------|------|---------|
| TimeFilter | `time.go` | Filters items older than MaxAge |
| DedupFilter | `dedup.go` | Removes duplicates by URL + normalized title |
| SourceBalanceFilter | `source.go` | Limits items per source |
| SourceFilter | `source.go` | Includes only items from specific sources |

### 2.4 Controller Interface

**File:** `internal/controller/controller.go`

```go
type EventType string
const (
    EventStarted   EventType = "started"
    EventProgress  EventType = "progress"
    EventCompleted EventType = "completed"
    EventError     EventType = "error"
)

type Event struct {
    Type       EventType
    Items      []model.Item
    Err        error
    FilterName string
    Progress   float64
}

type Controller interface {
    ID() string
    Refresh(ctx context.Context, store *model.Store, pool *work.Pool)
    Subscribe() <-chan Event
}
```

### 2.5 MainFeedController

**File:** `internal/controller/controllers/main_feed.go`

```go
type MainFeedConfig struct {
    MaxAge       time.Duration  // Default: 6h
    MaxPerSource int            // Default: 10
}

type MainFeedController struct {
    id       string
    pipeline *controller.Pipeline
    events   chan controller.Event
}
```

**Pipeline composition:**
```go
pipeline := controller.NewPipeline().
    Add(filters.NewTimeFilter(cfg.MaxAge)).
    Add(filters.NewDedupFilter()).
    Add(filters.NewSourceBalanceFilter(cfg.MaxPerSource))
```

### 2.6 Phase 2 Success Criteria

- [ ] Pipeline chains filters correctly
- [ ] Context cancellation propagates
- [ ] All basic filters pass tests
- [ ] MainFeedController refreshes correctly

---

## Phase 3: View Layer

**Goal:** Implement Bubble Tea views that consume controller output.

### 3.1 View Structure

```
internal/view/
├── app.go                 # Root model, orchestrates views
├── stream/
│   └── model.go           # Main feed view
├── work/
│   └── model.go           # Work queue visualization
└── styles/
    └── theme.go           # Lip Gloss styles
```

### 3.2 Stream View

**File:** `internal/view/stream/model.go`

- Time band dividers (Just Now, Past Hour, etc.)
- Source abbreviations for scannability
- Read/unread styling
- Cursor navigation with viewport scrolling

### 3.3 Work View

**File:** `internal/view/work/model.go`

- Active work items (spinner, description, elapsed time)
- Pending queue (priority order)
- Recent completed (last 10)

### 3.4 Root App

**File:** `internal/view/app.go`

```go
type ViewMode int
const (
    ModeStream ViewMode = iota
    ModeWork
    ModeHelp
)

type Model struct {
    store          *model.Store
    pool           *work.Pool
    fetchCtrl      *controllers.FetchController
    mainFeedCtrl   *controllers.MainFeedController
    controllerChan <-chan controller.Event
    workEventChan  <-chan work.Event
    // views
    streamView stream.Model
    workView   workview.Model
    mode       ViewMode
}
```

### 3.5 Key Bindings

| Key | Action |
|-----|--------|
| `j/k, up/down` | Navigate |
| `Enter` | Mark read |
| `g/G` | Top/bottom |
| `r` | Refresh |
| `/` | Command mode |
| `w` | Work view |
| `?` | Help |
| `q` | Quit |

### 3.6 Phase 3 Success Criteria

- [ ] Stream view renders items with time bands
- [ ] Navigation works correctly
- [ ] Work view shows pool state
- [ ] Mode switching works

---

## Phase 4: Intake Pipeline

**Goal:** Create the data pipeline that processes fetched items before storage.

### 4.1 Intake Pipeline

**File:** `internal/intake/intake.go`

```go
type Pipeline struct {
    embedder   embedding.Embedder
    dedupIndex *embedding.DedupIndex
    store      *model.Store
    pool       *work.Pool
}

type Result struct {
    Total       int
    Embedded    int
    Unique      int
    Duplicates  int
    Stored      int
    Errors      []error
}

func (p *Pipeline) Process(ctx context.Context, items []model.Item) Result
```

**Pipeline stages:**
1. **Embed Stage** - Generate embeddings (batch via Ollama)
2. **Dedup Stage** - Identify duplicates using HNSW similarity
3. **Store Stage** - Persist items and embeddings

### 4.2 Embedder

**File:** `internal/embedding/embedder.go`

```go
type Embedder interface {
    Embed(ctx context.Context, text string) ([]float64, error)
    EmbedBatch(ctx context.Context, texts []string) ([][]float64, error)
    Available() bool
    Dimension() int
}
```

### 4.3 Dedup Index

**File:** `internal/embedding/dedup.go`

```go
type DedupIndex struct {
    embedder  Embedder
    threshold float64  // Default 0.85
    index     *hnsw.Graph[string]
}

func (d *DedupIndex) GetPrimaryModelItems(items []model.Item) []model.Item
```

### 4.4 FetchController

**File:** `internal/controller/controllers/fetcher.go`

```go
type FetchController struct {
    sources     []fetch.SourceConfig
    store       *model.Store
    pool        *work.Pool
    lastFetched map[string]time.Time
}

func (c *FetchController) Start(ctx context.Context)
func (c *FetchController) Stop()
func (c *FetchController) FetchAll()
```

### 4.5 Phase 4 Success Criteria

- [ ] Intake pipeline embeds and stores items
- [ ] Dedup correctly identifies similar items
- [ ] FetchController periodically fetches
- [ ] Integration with work pool works

---

## Phase 5: Advanced Filters

**Goal:** Add embedding-based and reranking filters.

### 5.1 Embedding Filter

**File:** `internal/controller/filters/embedding.go`

```go
type EmbeddingFilter struct {
    store     *model.Store
    threshold float32
    halfLife  time.Duration  // Time decay
}
```

**Algorithm:**
1. Load embeddings from store
2. Compare to anchor embedding
3. Apply time decay: `score = cosineSim * 0.5^(age/halfLife)`
4. Filter items below threshold

### 5.2 Rerank Filter

**File:** `internal/controller/filters/rerank.go`

```go
type RerankFilter struct {
    reranker  rerank.Reranker
    threshold float32
    topK      int
}
```

**Key insight:** Reranking is a filter, not a sort. Items pass or fail the relevance threshold.

### 5.3 Complete Pipeline Example

```go
pipeline := controller.NewPipeline().
    Add(filters.NewTimeFilter(6*time.Hour)).              // O(n)
    Add(filters.NewDedupFilter()).                        // O(n)
    Add(filters.NewSourceBalanceFilter(10)).              // O(n)
    Add(filters.NewEmbeddingFilter(store, 0.6, 6*time.Hour)).  // O(n log k)
    Add(filters.NewRerankFilter(reranker, 5.0, 50))       // O(n) but n is small

// 12k items -> 500 (time) -> 400 (dedup) -> 200 (balance) -> 100 (embed) -> 50 (rerank)
```

### 5.4 Phase 5 Success Criteria

- [ ] EmbeddingFilter filters by similarity
- [ ] RerankFilter uses ML reranking as pass/fail
- [ ] Full pipeline reduces items at each stage
- [ ] Performance acceptable (< 1s typical refresh)

---

## Phase 6: Integration & Polish

**Goal:** Wire everything together and ensure production quality.

### 6.1 Main Entry Point

**File:** `cmd/observer/main.go`

```go
func main() {
    // MODEL layer
    store := model.NewStore(dbPath)
    defer store.Close()

    // GDC - Work pool
    pool := work.NewPool(0)
    pool.Start(context.Background())
    defer pool.Stop()

    // CONTROLLER layer
    fetchCtrl := controllers.NewFetchController(sources, store, pool)
    fetchCtrl.Start(context.Background())
    defer fetchCtrl.Stop()

    mainFeedCtrl := controllers.NewMainFeedController(config)

    // VIEW layer
    app := view.New(store, pool, fetchCtrl, mainFeedCtrl)

    // Run
    tea.NewProgram(app, tea.WithAltScreen()).Run()
}
```

### 6.2 Integration Architecture

```
                    ┌──────────────────────────────────────┐
                    │              VIEW (Bubble Tea)        │
                    │  ┌────────────────────────────────┐  │
                    │  │       Root App Model           │  │
                    │  │  ┌──────────┐  ┌───────────┐  │  │
                    │  │  │ Stream   │  │   Work    │  │  │
                    │  │  │  View    │  │   View    │  │  │
                    │  │  └────▲─────┘  └─────▲─────┘  │  │
                    │  └───────┼──────────────┼────────┘  │
                    └──────────┼──────────────┼───────────┘
                               │              │
              ┌────────────────┘              └────────────┐
              │  Items                            Events   │
              │                                            │
    ┌─────────┴──────────┐                    ┌───────────┴────────┐
    │    CONTROLLER      │                    │        GDC         │
    │  ┌──────────────┐  │                    │  ┌──────────────┐  │
    │  │ MainFeed     │  │                    │  │   Work Pool  │  │
    │  │ Controller   │  │                    │  │              │  │
    │  └──────┬───────┘  │                    │  └──────────────┘  │
    │         │          │                    └───────────▲────────┘
    │  ┌──────▼───────┐  │                                │
    │  │   Pipeline   │  │                        Submit work
    │  └──────┬───────┘  │                                │
    └─────────┼──────────┘                    ┌───────────┴────────┐
              │                               │   FetchController  │
              │ GetItemsSince()               │  ┌──────────────┐  │
              │                               │  │   Intake     │  │
              │                               │  │   Pipeline   │  │
              │                               │  └──────┬───────┘  │
              │                               └─────────┼──────────┘
    ┌─────────▼─────────────────────────────────────────▼────────┐
    │                         MODEL                               │
    │  ┌────────────────────────────────────────────────────┐    │
    │  │                    SQLite Store                     │    │
    │  └────────────────────────────────────────────────────┘    │
    └────────────────────────────────────────────────────────────┘
```

### 6.3 Phase 6 Success Criteria

- [ ] Application starts and runs
- [ ] Full data flow works end-to-end
- [ ] All tests pass
- [ ] Documentation complete

---

## Risk Analysis

### High Risk

| Risk | Impact | Mitigation |
|------|--------|------------|
| Ollama unavailable | Semantic features disabled | Graceful degradation to pass-through |
| SQLite slow at scale | UI lag | Proper indexing, limit queries, benchmark at 100k+ items |

### Medium Risk

| Risk | Impact | Mitigation |
|------|--------|------------|
| Filter pipeline slow | Refresh lag | Cheap filters first, progress events, benchmarking |
| Work pool starvation | High-priority delayed | Priority queue, monitor queue depth |

### Low Risk

| Risk | Impact | Mitigation |
|------|--------|------------|
| Memory with embeddings | OOM on constrained systems | Lazy loading, don't hold all in memory |

---

## Parallel Work Opportunities

**Stream 1: Core Infrastructure**
- Work pool (Phase 1)
- Model/Store (Phase 1)
- Basic filters (Phase 2)

**Stream 2: Embedding/ML**
- Embedder interface (Phase 4)
- Dedup index (Phase 4)
- Embedding filter (Phase 5)
- Reranker (Phase 5)

**Stream 3: UI**
- Styles (Phase 3)
- Stream view (Phase 3)
- Work view (Phase 3)
- Root app (Phase 3)

**Dependencies:**
- Phase 2 depends on Phase 1
- Phase 3 depends on Phase 2
- Phase 4 depends on Phase 1
- Phase 5 depends on Phase 4
- Phase 6 depends on all

---

## Dependencies

```go
// go.mod
require (
    modernc.org/sqlite v1.x.x           // Pure-Go SQLite
    github.com/charmbracelet/bubbletea  // TUI framework
    github.com/charmbracelet/bubbles    // TUI components
    github.com/charmbracelet/lipgloss   // TUI styling
    github.com/coder/hnsw               // HNSW for similarity search
)
```
