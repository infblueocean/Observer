# Observer v0.5 Implementation Plan (Revised)

## Executive Summary

This is a simplified, concrete implementation plan for Observer v0.5. It addresses criticisms from four adversarial reviews:

1. **Architecture Review**: Fix MVC violations, type mismatches, interface cohesion
2. **Concurrency Review**: Specify synchronization for every shared structure
3. **Testing Review**: Make interfaces mockable, add concrete testing strategy
4. **Pragmatism Review**: Remove over-engineering, simplify to real phases

**Core Changes from v1:**
- Removed work pool complexity (use simple goroutines)
- Removed event subscription system (use Bubble Tea messages)
- Fixed MVC: View receives items via messages, never holds Store reference
- Fixed Filter interface: sync filters don't see async concerns
- Consolidated to 4 real phases
- Explicit concurrency contracts for every shared structure

---

## Architecture Overview

```
cmd/observer/main.go           # Entry point, wires components
internal/
  store/
    store.go                   # SQLite persistence (concrete, not interface)
    store_test.go
  fetch/
    fetcher.go                 # RSS/HN/Reddit fetching
    fetcher_test.go
  filter/
    filter.go                  # Filter functions (not interfaces)
    filter_test.go
  embed/
    ollama.go                  # Ollama embeddings (concrete)
    ollama_test.go
  ui/
    app.go                     # Bubble Tea root model
    stream.go                  # Main feed view
    styles.go                  # Lip Gloss styles
    messages.go                # Bubble Tea messages (the only "event system")
```

**Key Simplifications:**
- No `internal/work/` package. Background work uses goroutines with `sync.WaitGroup`.
- No `internal/controller/` layer. The UI coordinates fetching and filtering directly.
- No interfaces for Store, Embedder, or Fetcher in production code. Interfaces exist only in test files for mocking.

---

## Phase 1: Store and Fetch (Foundation)

**Goal:** Fetch RSS feeds, store in SQLite, retrieve for display.

### 1.1 Store

**File:** `internal/store/store.go`

```go
// Store handles SQLite persistence. NOT an interface - concrete type.
// Thread-safety: All methods are safe for concurrent use via internal mutex.
type Store struct {
    db *sql.DB
    mu sync.RWMutex  // Protects all database operations
}

// Item represents stored content. Embeddings are NOT loaded by default.
type Item struct {
    ID         string
    SourceType string     // "rss", "hn", "reddit"
    SourceName string
    Title      string
    Summary    string
    URL        string
    Author     string
    Published  time.Time
    Fetched    time.Time
    Read       bool
    Saved      bool
}

// Open creates a new Store with the given database path.
// Creates tables if they don't exist.
func Open(dbPath string) (*Store, error)

// Close closes the database connection.
func (s *Store) Close() error

// SaveItems stores items, returning count of new items inserted.
// Duplicates (by URL) are silently ignored.
// Thread-safe: acquires write lock.
func (s *Store) SaveItems(items []Item) (int, error)

// GetItems retrieves items for display.
// Thread-safe: acquires read lock.
func (s *Store) GetItems(limit int, includeRead bool) ([]Item, error)

// GetItemsSince retrieves items published after the given time.
// Thread-safe: acquires read lock.
func (s *Store) GetItemsSince(since time.Time) ([]Item, error)

// MarkRead marks an item as read.
// Thread-safe: acquires write lock.
func (s *Store) MarkRead(id string) error

// MarkSaved toggles the saved state of an item.
// Thread-safe: acquires write lock.
func (s *Store) MarkSaved(id string, saved bool) error
```

**SQLite Schema:**

```sql
CREATE TABLE IF NOT EXISTS items (
    id TEXT PRIMARY KEY,
    source_type TEXT NOT NULL,
    source_name TEXT NOT NULL,
    title TEXT NOT NULL,
    summary TEXT,
    url TEXT UNIQUE,
    author TEXT,
    published_at DATETIME NOT NULL,
    fetched_at DATETIME NOT NULL,
    read INTEGER DEFAULT 0,
    saved INTEGER DEFAULT 0
);

CREATE INDEX IF NOT EXISTS idx_items_published ON items(published_at DESC);
CREATE INDEX IF NOT EXISTS idx_items_source ON items(source_name);
CREATE INDEX IF NOT EXISTS idx_items_url ON items(url);
```

**Concurrency Contract:**
- `Store.mu` is a `sync.RWMutex`
- Read methods (`GetItems`, `GetItemsSince`) acquire `mu.RLock()`
- Write methods (`SaveItems`, `MarkRead`, `MarkSaved`) acquire `mu.Lock()`
- All methods release locks via `defer`
- SQLite is opened with `_journal_mode=WAL` for better concurrent read performance

**Testing Strategy:**
```go
// store_test.go
func TestSaveItems(t *testing.T)           // Basic insert
func TestSaveItemsDuplicate(t *testing.T)  // URL dedup
func TestGetItems(t *testing.T)            // Retrieval with limit
func TestGetItemsIncludeRead(t *testing.T) // Read filter
func TestMarkRead(t *testing.T)            // State change
func TestConcurrentAccess(t *testing.T)    // Multiple goroutines read/write
```

### 1.2 Fetcher

**File:** `internal/fetch/fetcher.go`

```go
// Source represents a feed source configuration.
type Source struct {
    Type     string        // "rss", "hn", "reddit"
    Name     string        // Display name
    URL      string        // Feed URL
    Interval time.Duration // How often to fetch
}

// Fetcher retrieves items from sources. NOT an interface.
type Fetcher struct {
    client *http.Client
}

// NewFetcher creates a Fetcher with the given timeout.
func NewFetcher(timeout time.Duration) *Fetcher

// Fetch retrieves items from a source. Returns items and any error.
// Does NOT store items - caller decides what to do with them.
func (f *Fetcher) Fetch(ctx context.Context, src Source) ([]store.Item, error)
```

**Testing Strategy:**
```go
// fetcher_test.go
// Use httptest.Server for all tests - no real network calls

func TestFetchRSS(t *testing.T)           // Parse RSS XML
func TestFetchMalformedRSS(t *testing.T)  // Handle bad XML gracefully
func TestFetchTimeout(t *testing.T)       // Context cancellation
func TestFetchHTTPError(t *testing.T)     // 404, 500, etc.
```

### 1.3 Phase 1 Success Criteria

- [ ] Store saves and retrieves items
- [ ] Store handles concurrent access without races (`go test -race`)
- [ ] Fetcher parses RSS feeds
- [ ] Fetcher handles errors gracefully
- [ ] All tests pass

---

## Phase 2: UI (Users See Something)

**Goal:** Display items in a TUI with time bands and navigation.

**Rationale:** Ship the UI before background features. A TUI that shows items is useful. Background embedding without UI is useless.

### 2.1 Bubble Tea Messages

**File:** `internal/ui/messages.go`

```go
// Messages are the ONLY event system. No custom pub/sub.

// ItemsLoaded is sent when items are fetched from the store.
type ItemsLoaded struct {
    Items []store.Item
    Err   error
}

// ItemMarkedRead is sent when an item is marked as read.
type ItemMarkedRead struct {
    ID string
}

// FetchComplete is sent when background fetch finishes.
type FetchComplete struct {
    Source    string
    NewItems  int
    Err       error
}

// RefreshTick triggers periodic refresh.
type RefreshTick struct{}
```

### 2.2 App Model

**File:** `internal/ui/app.go`

```go
// App is the root Bubble Tea model.
// IMPORTANT: App does NOT hold *store.Store. It receives items via messages.
type App struct {
    // Dependencies passed as interfaces FOR TESTING ONLY
    // In production, main.go creates closures that call the real store
    loadItems   func() tea.Cmd
    markRead    func(id string) tea.Cmd
    triggerFetch func() tea.Cmd

    // View state
    items       []store.Item
    cursor      int
    viewport    viewport.Model
    err         error

    // UI state
    width       int
    height      int
}

// NewApp creates the app with dependency functions.
// These functions return tea.Cmd that produce messages.
func NewApp(loadItems, markRead, triggerFetch func) App

func (a App) Init() tea.Cmd
func (a App) Update(msg tea.Msg) (tea.Model, tea.Cmd)
func (a App) View() string
```

**Why functions instead of interfaces:**
- The View needs to trigger actions (load, mark read, fetch)
- It receives results via Bubble Tea messages
- Functions that return `tea.Cmd` are naturally mockable
- No need for a Controller layer - the functions ARE the controller

**In main.go:**
```go
func main() {
    st, _ := store.Open("observer.db")
    defer st.Close()

    fetcher := fetch.NewFetcher(30 * time.Second)
    sources := loadSources()

    app := ui.NewApp(
        // loadItems: returns a Cmd that loads from store
        func() tea.Cmd {
            return func() tea.Msg {
                items, err := st.GetItems(500, false)
                return ui.ItemsLoaded{Items: items, Err: err}
            }
        },
        // markRead: returns a Cmd that marks item read
        func(id string) tea.Cmd {
            return func() tea.Msg {
                st.MarkRead(id)
                return ui.ItemMarkedRead{ID: id}
            }
        },
        // triggerFetch: returns a Cmd that fetches all sources
        func() tea.Cmd {
            return func() tea.Msg {
                // Fetch in goroutine, results come back as messages
                // (detailed in Phase 3)
            }
        },
    )

    tea.NewProgram(app, tea.WithAltScreen()).Run()
}
```

### 2.3 Stream View

**File:** `internal/ui/stream.go`

```go
// RenderStream renders the item list with time bands.
func RenderStream(items []store.Item, cursor int, width, height int) string

// TimeBand returns a display string for grouping items.
// This is a VIEW concern, not a model concern.
func TimeBand(published time.Time) string {
    age := time.Since(published)
    switch {
    case age < 15*time.Minute:
        return "Just Now"
    case age < 1*time.Hour:
        return "Past Hour"
    case age < 24*time.Hour:
        return "Today"
    case age < 48*time.Hour:
        return "Yesterday"
    default:
        return "Older"
    }
}
```

### 2.4 Key Bindings

| Key | Action |
|-----|--------|
| `j/k` or `up/down` | Navigate |
| `Enter` | Mark read |
| `g/G` | Top/bottom |
| `r` | Refresh |
| `q` | Quit |

### 2.5 Phase 2 Success Criteria

- [ ] TUI displays items with time band groupings
- [ ] Navigation works (j/k, g/G)
- [ ] Enter marks item as read
- [ ] 'r' triggers refresh
- [ ] 'q' quits cleanly
- [ ] App receives items via messages (no Store reference)

---

## Phase 3: Background Fetch (Continuous Updates)

**Goal:** Periodically fetch new items in the background.

### 3.1 Background Goroutine Pattern

**No work pool.** Just a goroutine with a ticker.

```go
// In main.go or a small coordinator

type Coordinator struct {
    store    *store.Store
    fetcher  *fetch.Fetcher
    sources  []fetch.Source

    mu       sync.Mutex        // Protects lastFetch
    lastFetch map[string]time.Time

    stopCh   chan struct{}
    wg       sync.WaitGroup
}

func (c *Coordinator) Start(ctx context.Context, program *tea.Program) {
    c.wg.Add(1)
    go func() {
        defer c.wg.Done()
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for {
            select {
            case <-ctx.Done():
                return
            case <-c.stopCh:
                return
            case <-ticker.C:
                c.fetchAll(ctx, program)
            }
        }
    }()
}

func (c *Coordinator) Stop() {
    close(c.stopCh)
    c.wg.Wait()  // Wait for goroutine to finish
}

func (c *Coordinator) fetchAll(ctx context.Context, program *tea.Program) {
    for _, src := range c.sources {
        items, err := c.fetcher.Fetch(ctx, src)
        if err != nil {
            program.Send(ui.FetchComplete{Source: src.Name, Err: err})
            continue
        }

        n, _ := c.store.SaveItems(items)

        c.mu.Lock()
        c.lastFetch[src.Name] = time.Now()
        c.mu.Unlock()

        program.Send(ui.FetchComplete{Source: src.Name, NewItems: n})
    }
}
```

**Concurrency Contract for Coordinator:**
- `lastFetch` map protected by `mu sync.Mutex`
- Lock acquired only for map access, released immediately
- `stopCh` is closed exactly once by `Stop()`
- `wg.Wait()` ensures goroutine completes before `Stop()` returns

### 3.2 Graceful Shutdown

```go
func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    st, _ := store.Open("observer.db")
    defer st.Close()

    coord := NewCoordinator(st, fetcher, sources)

    // Start background fetch AFTER program starts
    var program *tea.Program

    app := ui.NewApp(/* ... */)
    program = tea.NewProgram(app, tea.WithAltScreen())

    coord.Start(ctx, program)

    // Run blocks until quit
    program.Run()

    // Shutdown sequence:
    // 1. Cancel context (signals goroutines to stop)
    // 2. coord.Stop() waits for background goroutine
    // 3. st.Close() closes database
    cancel()
    coord.Stop()
}
```

### 3.3 Phase 3 Success Criteria

- [ ] Background fetch runs every 5 minutes
- [ ] New items appear in UI after fetch
- [ ] Graceful shutdown waits for in-flight fetches
- [ ] No goroutine leaks (verified with runtime inspection)
- [ ] `lastFetch` map access is race-free (`go test -race`)

---

## Phase 4: Filters and Embeddings (When Needed)

**Goal:** Add filtering and semantic features when the item list becomes unmanageable.

**This phase is optional for v0.5.** Only implement when:
- Item count exceeds ~500 and scrolling becomes painful
- Users request semantic dedup or similarity features

### 4.1 Filter Functions (Not Interfaces)

**File:** `internal/filter/filter.go`

```go
// Filter functions are simple: []Item in, []Item out.
// No interfaces, no work pools, no async.

// ByAge removes items older than maxAge.
func ByAge(items []store.Item, maxAge time.Duration) []store.Item

// BySource keeps only items from specified sources.
func BySource(items []store.Item, sources []string) []store.Item

// Dedup removes items with duplicate URLs or very similar titles.
func Dedup(items []store.Item) []store.Item

// Limit caps the number of items per source.
func LimitPerSource(items []store.Item, maxPerSource int) []store.Item
```

**Usage in UI:**
```go
// In App.Update when ItemsLoaded arrives:
items = filter.ByAge(items, 6*time.Hour)
items = filter.Dedup(items)
items = filter.LimitPerSource(items, 20)
```

**Testing Strategy:**
```go
func TestByAge(t *testing.T)           // Keeps recent, removes old
func TestBySource(t *testing.T)        // Filters by source name
func TestDedup(t *testing.T)           // URL and title similarity
func TestLimitPerSource(t *testing.T)  // Caps per source
```

### 4.2 Embeddings (Optional)

**Only add if semantic features are needed.**

**File:** `internal/embed/ollama.go`

```go
// OllamaEmbedder generates embeddings via local Ollama.
// NOT an interface - concrete type. Add interface only if second impl needed.
type OllamaEmbedder struct {
    baseURL string
    model   string
    client  *http.Client
}

func NewOllamaEmbedder(baseURL, model string) *OllamaEmbedder

// Available returns true if Ollama is reachable.
func (e *OllamaEmbedder) Available() bool

// Embed returns embedding for text. Returns nil if Ollama unavailable.
// Embedding type is float32 (matches storage, GPU precision).
func (e *OllamaEmbedder) Embed(ctx context.Context, text string) ([]float32, error)

// EmbedBatch embeds multiple texts. Partial failures return partial results.
// Returns: embeddings slice (same length as texts), errors slice
func (e *OllamaEmbedder) EmbedBatch(ctx context.Context, texts []string) ([][]float32, []error)
```

**Type Decision:** `float32` everywhere. Matches:
- GPU compute precision
- Storage efficiency (half the memory of float64)
- Ollama's actual output (float32)

**Embedding Storage (extend store):**
```sql
-- Add to items table
ALTER TABLE items ADD COLUMN embedding BLOB;

CREATE INDEX idx_items_no_embedding ON items(id) WHERE embedding IS NULL;
```

```go
// Additional Store methods (only add when embeddings are implemented)
func (s *Store) SaveEmbedding(id string, embedding []float32) error
func (s *Store) GetItemsNeedingEmbedding(limit int) ([]Item, error)
func (s *Store) GetItemsWithEmbeddings(ids []string) (map[string][]float32, error)
```

**Graceful Degradation:**
```go
func (e *OllamaEmbedder) Embed(ctx context.Context, text string) ([]float32, error) {
    if !e.Available() {
        return nil, nil  // Not an error - just unavailable
    }
    // ... actual embedding
}
```

### 4.3 Semantic Dedup (Optional)

**Only add if basic URL/title dedup is insufficient.**

```go
// SemanticDedup removes items with similar embeddings.
// Requires embeddings to be loaded.
func SemanticDedup(items []store.Item, embeddings map[string][]float32, threshold float32) []store.Item
```

**No HNSW index in v0.5.** For <10k items, brute-force cosine similarity is fast enough (~100ms). Add HNSW in v0.6 if item count justifies it.

### 4.4 Phase 4 Success Criteria

- [ ] Filter functions reduce item count as expected
- [ ] Filters are pure functions (no side effects)
- [ ] Ollama embedding works when available
- [ ] Graceful degradation when Ollama unavailable
- [ ] `float32` used consistently for embeddings

---

## Testing Architecture

### Mock Strategy

Interfaces exist ONLY in test files, not production code.

**File:** `internal/store/store_test.go`
```go
// StoreInterface is used ONLY for testing UI components
type StoreInterface interface {
    GetItems(limit int, includeRead bool) ([]Item, error)
    MarkRead(id string) error
}

// Verify Store implements StoreInterface
var _ StoreInterface = (*Store)(nil)
```

**File:** `internal/ui/app_test.go`
```go
func TestAppLoadsItems(t *testing.T) {
    // Mock via function injection
    app := NewApp(
        func() tea.Cmd {
            return func() tea.Msg {
                return ItemsLoaded{Items: testItems}
            }
        },
        func(id string) tea.Cmd { return nil },
        func() tea.Cmd { return nil },
    )

    // Send Init, verify items appear
}
```

### Concurrency Testing

```go
func TestStoreConcurrent(t *testing.T) {
    st, _ := store.Open(":memory:")
    defer st.Close()

    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(2)
        go func(n int) {
            defer wg.Done()
            st.SaveItems([]Item{{ID: fmt.Sprintf("w%d", n)}})
        }(i)
        go func() {
            defer wg.Done()
            st.GetItems(100, true)
        }()
    }
    wg.Wait()
}
```

Run with: `go test -race ./...`

### Test Categories

| Category | Location | Run Command |
|----------|----------|-------------|
| Unit | `*_test.go` in each package | `go test ./...` |
| Race | Same files | `go test -race ./...` |
| Integration | `test/integration/` (Phase 4+) | `go test ./test/integration/` |

---

## Concurrency Summary

Every shared data structure with explicit synchronization:

| Structure | Location | Protection | Who Reads | Who Writes |
|-----------|----------|------------|-----------|------------|
| `Store.db` | store.go | `Store.mu sync.RWMutex` | UI (via functions), Coordinator | Coordinator, UI mark-read |
| `Coordinator.lastFetch` | main.go | `Coordinator.mu sync.Mutex` | (internal only) | Coordinator goroutine |
| `App.items` | app.go | None needed - Bubble Tea is single-threaded | App.View() | App.Update() |

**Channel Contracts:**

| Channel | Buffer Size | Creator | Closer | Backpressure |
|---------|-------------|---------|--------|--------------|
| `Coordinator.stopCh` | 0 (unbuffered) | `NewCoordinator` | `Stop()` | N/A - signal only |
| Bubble Tea internal | (managed by tea) | tea.Program | tea.Program | tea.Program handles |

**There are no custom event channels.** All events flow through Bubble Tea's message system.

---

## What's NOT in v0.5

Explicitly deferred to v0.6+:

- **Work pool / job queue**: Use goroutines
- **Event subscription system**: Use Bubble Tea messages
- **Controller interfaces**: Concrete types only
- **HNSW index**: Brute-force similarity for <10k items
- **Reranking filters**: Add when user requests semantic ranking
- **Work queue visualization**: Add when debugging needs it
- **Multiple priority levels**: FIFO is fine

---

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| Ollama unavailable | `Available()` check, nil embedding = skip semantic features |
| SQLite slow at scale | WAL mode, proper indexes, limit queries to 500 items |
| Too many items | ByAge filter default 6h, LimitPerSource default 20 |
| Fetch errors | Log and continue, show error count in status bar |
| Race conditions | Explicit mutex for every shared structure, `-race` in CI |

---

## Success Criteria (Full v0.5)

- [ ] Fetch RSS feeds from configured sources
- [ ] Store items in SQLite
- [ ] Display items in TUI with time bands
- [ ] Navigate with j/k, mark read with Enter
- [ ] Background refresh every 5 minutes
- [ ] Graceful shutdown (no goroutine leaks)
- [ ] All tests pass with `-race`
- [ ] Works without Ollama (graceful degradation)

---

## Appendix: Addressing Review Criticisms

| Criticism | How Addressed |
|-----------|---------------|
| View holds Store reference | View receives items via Bubble Tea messages only |
| Filter interface has work pool | Filter functions take no pool (sync only) |
| float32/float64 mismatch | float32 everywhere |
| 6 phases too many | 4 phases: Store+Fetch, UI, Background, Filters |
| Work pool over-engineered | Deleted. Use goroutines. |
| Event subscription system | Deleted. Use Bubble Tea messages. |
| Controller interface premature | Deleted. Concrete types only. |
| Embedder interface premature | Deleted. Concrete OllamaEmbedder. |
| No channel contracts | Explicit table of all channels |
| No synchronization specified | Explicit table of all mutexes |
| Phase 3 before Phase 4 wrong | UI (Phase 2) before Background (Phase 3) |
| TimeBand in Model layer | Moved to ui/stream.go (View concern) |
| Embedding in Item struct | Loaded separately, not in default Item |
| Interfaces not mockable | Functions injected for testing |
| DedupIndex persistence unclear | No HNSW in v0.5 - brute force is fine |
| Ring buffer for history | Deleted. Use logging. |
| Priority levels | Deleted. FIFO queue. |
